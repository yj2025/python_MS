API : 81319711-16d7-47a0-a339-5880a0b3f13e
http://localhost:8888/
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
							<<main.py>>

import sys
import subprocess		subprocess 모듈은 외부 프로그램을 실행할 수 있게 해줌
			subprocess.check_call() 사용 -> 외부 명령어 실행

subprocess.check_call([sys.executable, "-m", "pip", "install", "konlpy"])

sys.executable	:	인터프리터의 경로					현재 실행 중인 파이썬 인터프리터의 경로를 가져옴
"-m"		:	파이썬 모듈 실행할 때 사용하는 옵션			지정된 모듈을 스크립트처럼 실행할 수 있게 해줌
"pip"		:	파이썬 패키지 관리자 pip 실행
"konlpy"		:	한국어 자연어 처리를 위한 파이썬 라이브러리

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 객체 생성		__name__ 	:	 현재 파이썬 파일의 모듈 이름
app = Flask(__name__)		
Flask : 파이썬으로 작성된 마이크로 웹 프레임워크
	- URL을 Python 코드의 함수나 메서드에 매핑할 수 있는 라우팅 메커니즘을 제공		- HTTP 요청 및 응답 처리를 간소화

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 특정 URL 경로에 대한 처리를 정의
@app.route('/')
def index():
    return render_template('main.html', rows=board, qnas=chatbot.src)

@app.route('/'):	decorator. URL 경로('/')에 대한 요청이 들어왔을 때 실행할 함수를 지정
		사용자가 웹사이트의 홈 페이지(루트 경로)를 방문하면 index() 함수가 호출

render_template는 Flask에서 HTML 템플릿 파일을 렌더링(실행)하는 함수	->	main.html 파일을 사용하고, 템플릿에 두 개의 변수를 전달

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# Flask에서 POST 요청을 처리하는 라우트를 정의한 부분
@app.route('/question', methods=["POST"])
def question():
    if request.method == "POST":
        board.append([request.form["context"], chatbot.action(request.form["context"])])
        return redirect(url_for("index"))
    else:
        return render_template("main.html", rows=board, qnas=chatbot.src)


/question		:	경로로 POST 요청이 들어올 때 이 함수를 호출
methods=["POST"]	: 	이 라우트가 오직 POST 요청만 처리하도록 설정

board.append([request.form["context"], chatbot.action(request.form["context"])])
request.form["context"]	: 사용자가 폼에서 제출한 데이터 중 "context"라는 이름을 가진 값을 가져와.
chatbot.action(request.form["context"])	: chatbot 객체의 action 메서드를 호출해서, 사용자가 입력한 "context"에 대해 챗봇이 어떤 응답을 해야 할지 처리하는 부분

그 후 board 리스트에 [사용자 입력, 챗봇 응답]을 추가

return redirect(url_for("index"))	: POST 요청이 처리된 후, index 라우트로 리다이렉트하여 사용자를 홈페이지로 보내기
				  url_for("index")는 index라는 함수가 처리하는 URL로 리다이렉트하는 코드

else:	# POST가 아닌 GET 요청
    return render_template("main.html", rows=board, qnas=chatbot.src)

GET 요청이 들어오면 main.html 템플릿을 렌더링하면서 board와 chatbot.src 데이터를 템플릿에 전달
rows는 board 데이터를, qnas는 chatbot.src 데이터를 템플릿에서 사용할 수 있도록 함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# 실행
if __name__ == '__main__':
    app.run(
        host='0.0.0.0', # 모든 IP에서 접근 가능하도록 설정 (기본값 : '127.0.0.1'(localhost))
        debug=True,     # 디버그 모드 활성화 (코드 변경 시 자동 재시작, 에러 상세 출력)
        port=8888       # 8888번 포트에서 서버 실행 (기본값: 5000)
    )

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
<main.py 요약>
1. 사용자가 POST 방식으로 질문을 제출하면, 그 질문을 board에 추가하고 챗봇의 응답도 함께 기록
2. 이후 홈페이지(index)로 리다이렉트해서 새로 고침된 페이지를 보여줌
3. 만약 GET 방식으로 요청이 들어오면, main.html을 렌더링하면서 board와 chatbot.src 데이터를 전달





							<<chatbot.py>>

import urllib3, json
from konlpy.tag import Okt

# API 키 입력
openApiURL = "http://aiopen.etri.re.kr:8000/MRCServlet"     #  etri의 API에 요청 보내기
accessKey = "81319711-16d7-47a0-a339-5880a0b3f13e"  


# info.txt 파일 경로 확인 후 파일 읽기
try:
    src = open('info.txt', 'r', encoding='utf-8').readlines()
    passage = ''.join(src)
except FileNotFoundError:
    print("info.txt 파일을 찾을 수 없습니다.")
    passage = ''

# 객체 생성
http = urllib3.PoolManager()
okt = Okt()     # (Open Korea Text)

# 실행
def action(q):
    q = okt.normalize(q)    #  정규화	(불필요한 공백이나 특수 문자 등을 제거하고, 통일된 형태로 만듦)

    if len(okt.nouns(q)):
        requestJson = {"argument": {"question": q, "passage": passage}}
        response = http.request("POST", openApiURL,
                                headers={"Content-Type": "application/json; charset=UTF-8", "Authorization": accessKey},
                                body=json.dumps(requestJson))
        response = json.loads(str(response.data, "utf-8"))

        if float(response['return_object']['MRCInfo']['confidence']) > 0.10:
            answer = response['return_object']['MRCInfo']['answer']
            if '[END]' in answer:
                answer = answer[:answer.index('[END]')]

            answer = passage[passage.index(answer): passage.index('[END]', passage.index(answer))]
            return answer

    josa = ''
    return '"' + q + '"' + josa + '라는 문장은 아직 제대로 이해하지 못했습니다. 이 사항은 챗봇 응답에 추가될 예정입니다.'


<chatbot.py 요약>
1. 사용자가 질문을 입력하면, 명사를 추출하고, 외부 API를 호출해서 답을 구함
2. 답변의 신뢰도가 충분히 높다면, 그 답을 passage에서 잘라서 반환.
3. 만약 답을 못 찾으면, "이 문장은 아직 제대로 이해하지 못했습니다"라는 메시지를 반환.


